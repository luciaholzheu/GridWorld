Set 3:

1. Loaction locl1 = locl.getAdjacentLocation(whatever place is needed)

2. False

3. (3,5)

4. Dir has a value of 135

5. It is base off of the direction you choose, North and south change the second variable for the vertical shift and east and west change the horizontal variable which is the first one. It gets the original spot and gets the direction of the second spot to determine it.

Set 4:

1. You can obtain the count of objects in the world by using the getOccupiedLocations to check each of the grid loactions that are occupied by an object. To find the unoccupied locations use the getEmpytyAdjacentLocations to find each of the spots on the grid that are unoccupied.

2. Use the get(Location loc) method to see if the spot is occupied.

3. You have to call upon the super to access the methods located in other files

4. In this case it is easier to use ArrayList because is much simpler to add and subtract objects to the list because Arrays you would have to change multiple parts to make it work.

Set 5:

1. Setting the color, location, and behaviors.

2. The color is blue and faces north.

3. It is created as a class so it can be accessed by multiple other classes instead of being copied over for each one.

4. You can place multiple bugs into the world however they can not be placed on top of eachother, an actor can not remove its self from the grid twice because it is only one actor. It can create its self and remove itsself multiple times.

5. You can call the turn method twice to make it move 90 degrees.

Set 6:

1. if (gr == null) return false

2. return (neighbor == null) || (neighbor instanceOf rock)

3. isValid and the get beecause the they both ensure that the area of the world is valid before it moves.

4. getAdjacentLocation because it gets the location in which the bug is looking.

5. The methods from canMove are getLocation, getGrid, and getDirection.

6. It rotates 45 degrees to the right and then moves.

7. Loc is needed because it simplifies the method without having to call multiple getLocations.

8. So you can distinguish which bug dropped which color of flower

9. No it would not leave a flower if the method removeSelfFromGrid was called, there would be nothing

10. flower.putSelfToGrid takes the flower method and adds a flower.

11. It would turn 4 times to be 180 degrees.


Jumping bug code:

1.
a. Checks two spots away to see if it is a flower or a rock. If it is a rock it will turn 45 degrees to the right. If it is a flower the bug will continue to jump onto the flower.
b.It will check two spots ahead of itself and then turn 45 degrees.
c.It will check to see if it is a the edge of the grid and then turn 45 degrees.
d.It would do the same thing as if a rock was in the way.
e.The bug will check to see if the second space is clear and then jump over the bug infront of it and if it isnt, it will turn 45 degrees.
f.None that we know of now.

2.
a.It would extend to bug.
b.All of the other bug runners that we made are similar to jumper.
c.Yes there should be a constructor that will only initiailize the color of the bug and the other physical characteristics.
d. the dropFlower method and the other act methods because the jumper is not a regular bug.
e. Jump, canMove2.
f. Our plan is to place other actors and objects in the world to see how it reacts to them to see if it breaks our rules.


